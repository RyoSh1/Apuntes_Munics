# Tema 1: 

## ¿Qué es el malware?

Software malicioso, es decir, código para lograr acciones "malvadas".

### ¿Para qué analizarlo?

- Comprobación de daño.
- Identificación de vulnerabilidades.
- Encontrar a los malos

### ¿Porqué hace malware la gente?

1. Inicios: Rober Morris hizo un malware de propagación para ver el tamaño de internet.
2. En los 90: Por gloria personal, displays.
3. Actualidad: Por dinero, contraseñas, tarjetas, etc.
4. Futuro?: Ciberguerras, obtención de inteligencia, zerodays...

### Malware a lo largo del tiempo

1998. Gusano Morris usa finger daemon.
1990. Mark Washburn malware polimórfico.
2001. Gusano Code Red usa un exploit de MS web server.
2004. Troyano Vundo publicidad.
2005. Sony infecta CDs con rootkit para prevenir piratería.
2008. Koobface RAT se propaga por Facebook y Myspace.
2008. /10 Stuxnet utiliza cuatro Zero-days en windows (Iran).
2013. Mandiant publica APT1, campaña china de ciber espionaje.
2015. Duqu2 evolución de Stuxnet, atacó Kapersky.

### Preguntas prácticas

1. ¿Propósito del malware?
2. ¿Cuando y cómo he sido infectado?
3. ¿De quién he sido objetivo?
4. ¿Cómo puedo evitarlo?
5. ¿Qué me han robado?
6. ¿Se esparce por si mismo?
7. ¿Cómo puedo encontrarlo en otra parte?
8. ¿ Cómo puedo evitar que ocurra en un futuro?

### Preguntas técnicas

1. ¿Indicios de red?
2. ¿Indicios en envíos de mensajes?
3. ¿Persistencia?
4. ¿Fecha de compilación?
5. ¿Fecha de instalación?
6. ¿Lenguaje de programación?
7. ¿Empaquetado?
8. ¿Tiene funcionalidades rootkit?

### Términos típicos

- Virus: Malware que intenta reproducirse en programas similares al que se encuentra hasta que consigue permisos para poder ejecutar su software malicioso.
- Gusano: Malware autocontenido que busca replicarse y esparcirse a lo largo de las redes disponibles para el equipo en el que se encuentra.
- Trojan: Programa que de primeras parece útil o seguro, pero después producen acciones maliciosas.
- Backdoor: Puertas ocultas para que un atacante o empresa pueda acceder al sistema sin tener en cuenta la seguridad.
- Rootkit: Herramientas que modifican el sistema operativo para que el ataque permanezca oculto en el sistema.
- Sniffer: Software o hardware que recoje paquetes en un canal de comunicación para su monitorización o análisis.
- Spyware: Software instalado en un equipo sin que el usuario sea consciente, el cual obtiene información privada.
- Adware: Software instalado que informa sobre hábitos de búsqueda y gustos del usuario para propósitos publicitarios.
- Exploit: Software o secuencia de comandos que aprovecha un bug o una vulnerabilidad para producir comportamiento inesperado en el sistema.
- Disassembler:  Programa que recibe un archivo binario y genera ficheros de texto con el lenguaje ensamblador para el programa.
- Decompiler: Programa que recibe un archivo binario ejecutable e intenta producir lenguaje de alto nivel legible.
- Debugger: Programa que permite a los desarrolladores observar el proceso del código durante su ejecución.
- Profilers: Programa que realiza un análisis dinámico de un programa sobre el espacio de memoria, complejidad, llamadas a funciones y rendimiento.
- Sinkhole: Host en la red interna que recibe trafico redireccionado de dominios maliciosos.
- IDS (Sistema de detección de intrusiones): Software/Hardware para detectar acceso no autorizado a un host o a una red.
- IPS (Intrusion Prevention System): Igual que IDS, pero intentan parar las intrusiones.
- Operations Security (OPSEC): El proceso de prevenir adversarios de obtener información sensible.
- Reverse Engineering: Es el proceso de a partir de un producto inicial, intentar determinar cuales son sus componentes, cómo interactúan entre sí y su proceso de desarrollo.

### Extras

Ransomware, Creeping, Vamping, Sexting, Phising, Pharming, Bloatware, Doxing, Grooming, Cyberbulling, Cyberstalking, Flaming.

# Tema 1.2: Goals and Types

### Goals of Malware Analysis

El objetivo del análisis de malware es comprender cómo una pieza de malware específica funciona y como protegerse ante ella.

Three questions:
- Cómo terminó infectada la máquina?
- Que hace exactamente?
- Cómo podemos prevenirlo?

### Types of Malware Analysis

Existen dos tipos de análisis estático o de código y dinámico o de comportamiento.

Es importante realizar ambos análisis para averiguar cómo funciona perfectamente.

### Análisis estático

El análisis estático es más seguro, pero es más lento y tedioso, hay un montón de herramientas incluidas.

Durante el análisis de código, software antivirus analizará malware, scripts y búsqueda de cadenas específicas.

Al hacer reverse coding es importante revisar las leyes nacionales.

Tras terminar el análisis es importante entender como funciona el código base.

### Analisis dinámico

Es una forma más veloz de analizar, pero es importante no tener el laboratorio de pruebas conectado a una red externa.

El análisis dinámico se basa en observar cómo el malware se comporta y qué cambios provoca en el sistema base. Hay que comprobar cambios en el sistema y comportamientos inusuales.

Los cambios en el sistema que provocan un aviso deberían ser:
- Ficheros añadidos y/o modificados.
- Nuevos servicios de red instalados.
- Nuevos procesos.
- Modificaciones en los registros.
- Cambios en la configuración de servicios del sistema (DNS).

Además de lo último es necesario examinar el tráfico.

Extras-Armored malware: Encryption, Compression, Obfuscation, Anti-Patching(CRC check), Anti-tracing, Anti-unpacking, Anti-vmware, Self-mutating(poli/meta-morphic), Restrictive dates, Password protected.

# x86 Architecture

### Niveles de abstracción

Application > Algorithm > Programming Language > Assembly Language > Machine Code > Instruction Set Architecture > Micro Architecture > Gates/Registers > Devices(Transistors) > Physics

### Ingeniería inversa

En algunos lenguajes existen decompiladores que proveen descripción de código de alto nivel.

Normalmente el lenguaje ensamblador es la capa más alta en la que se puede recuperar los datos de forma consistente.

## x86 Architecture

Es el objetivo más explotado debido a que es el tipo de arquitectura más utilizado: 32-bits y 64-bits.

### Instrucciónes y Operadores

- Instrucción: Cada instrucción corresponde a un código de operación que indica al procesador que operación realizar.
- Operadores: Se usan para identificar los datos utilizados por una instrucción( Valores fijos, Registros u operaciones de memoria).

### Registros

- Registros generales: usados por la CPU.
- Registros de segmento: Usados para trackear secciones de memoria.
- Flags de estado: Para la toma de decisiones.
- Puntero de instrucciones (EIP): Para trackear la siguiente instrucción.

### Flags

El registro de EFLAGS tiene 32 bits. Cada bit es una flag(1,0), controlan operaciones de la CPU o resultados de operaciones.

- ZF(Zero flag): Cuando el resultado es 0.
- CF(Carry Flag): Cuando el resultado es demasiado grande o pequeño para el destino.
- SF(Sign Flag): Cuando el resultado es negativo.
- TF(Trap Flag): Para debugging.

#### Instrucciones de datos

- mov destination, source: moves data from source to destination.
- lea destination, source: loads an effective addres to a destination.

#### Instrucciones aritméticas

- add/sub
- mul/div
- Logical (or/and/xor)
- shr/shl destination, count: Shift registers right/left
- ror/rol rotation instruccions: Rotate bits to the other end.

#### Llamadas a funciones

- Prólogo de funciones: Lineas al inicio que preparan el stack y registros.
- Epílogo de funciones: Líneas al final de una funcion, recuperan el estado del stack y los registros previos a la función.

### El Stack de memoria

El stack crece desde una dirección alta de memoria hacia zero.

Current stack < Caller's stack < 

Instrucciones: push, pop, call, ret, enter y leave.

Convenciones: cdecl (limpia el stack), stdcall (limpia el stack antes de hacer return), fastcall (Los primeros argumentos pasan a los registros).

Dentro de un function stack frame dado las variables estarán en un offset negativo desde EBP y los argumentos en un offset positivo.

#### Condicionales

- test value,value: Idéntico a la instrucción and, pero los operadores no se modifican, solo settea la ZF.

- cpm destination, source: Idéntico a sub, pero no afecta a los operadores, se actualizan ZF y SF.

#### Ramas (Branching)

- jmp location: Una rama es una secuencia de código que se ejecuta condicionalmente saltando un grupo de instrucciones.

#### Repeticiones

- rep instructions: Set de instrucciones para manipular buffers de datos como arrays de bytes usando movsx, cmpsx, stosx, scasx.

scasx: Def FORO, comparar un valor almacenado en un registro con un valor en la memoria (específicamente en la dirección apuntada por el registro ESI o EDI, dependiendo del modo). Es parte del grupo de instrucciones conocidas como String Operations (operaciones con cadenas) y se utiliza para recorrer y comparar secuencias de datos en la memoria.

# The Microsoft Arquitecture

### Windows API

La API de windows es la forma estándar de interactuar con el SO y se usa en los DLLs.

Destacado: kernel32, wininet.dll, advapi32.dll.

### Proccesses, Threads and Context

Proceso: Contenedor de recursos que tiene su propio espacio de direcciones virtuales, hilos e información.

Hilos: Gestionados y ejecutados por el SO, los hilos pertenecen a un único proceso y comparten su espacio de direcciones.

Contexto de hilos: El contexto de hilos trackea el estado de un hilo (valores en registros).

### Dynamic Link Library (DLL)

Son librerías que se enlazan solo cuando se necesitan, por ejemplo al abrir una carpeta, así pesan menos y solo se enlazan al necesitar funcionalidades.

Todos los procesos comparten las DLLs cargadas, esto guarda espacio y cada cambio solo afecta el espacio de direcciones de ese proceso.

Los DLLs exportan un método interfazo que será usado por los procesos.

#### Registros

Un arbol jerárquico en el que se guarda información de forma: clave-valor. regedit para navegarlo.

#### Servicios

Un servicio es similar a un proceso pero instalado en el disco/registro. No los genera el usuario sino por el sistema y cumplen funcionalidades esenciales en segundo plano.

#### Handlers

Un puntero abstracto a un proceso,fichero,clave del registro,servicio,etc.

### .com Files vs COM Platform

Un archivo .com es un ejecutable de 8bits de la época MS-DOS, con un tamaño máximo de 64KB (DOS-segment) que guarda código y datos.
Se usan por escritores de malware para aprovecharse de ususarios sin conocimientos que lo vinculan a las url .com.

Un "Component Object Model" es un estándar de interfaz binario para componentes de software introducido por Microsoft en 1993. En esencia es un lenguaje neutro para implementar objetos que pudieran ser ejecutados en entornos diferentes a aquel en el que se crearon.
Problema: Los componentes COM se ejecutan como código nativo en la máquina del usuario, por lo que apenas tienen restricciones.

# Malware analysis and tools

#### Create a Sandbox

No queremos que el malware toque una red real, por ello hacemos lo siguiente:
- Host-only networking.
- Establecemos servicios reales (DNS, Web, etc).
- Creamos puestos activos escuchando.
- Servidores de control.

### Ventajas y desventajas de la virtualización

Ventajas:
- Reducir el coste en hardware para solo necesitar 1 o 2 dispositivos físicos.
- Posibilidad de tomar snapshots antes de realizar análisis.
- Es posible deshabilitar el acceso a la tarjeta de red.
Desventajas:
- Algunos malware más complejos realizan intentos de detectar VMs.
- La virtualización no es perfecta y puede haber diferencias con un equipo real.
- Pueden existir gusanos zero day que escapen la sandbox.

#### Virtualización del SO

#### Virtualización-Análisis

Para realizar el análisis realizamos primero el análisis estático y después el dinámico, puesto que hay información del primero que será bueno para el segundo.

Primero elegimos las herramientas, creamos el laboratorio y tomamos una snapshot. Tras el análisis comparamos los hashes de las herramientas por si han sido modificadas.
Herramientas: Debuggers, Disassemblers, de-compilers y un-packer.

### Análisis estático

1. Analizamos el malware con varios antivirus.
2. Abrimos el malware en un editor hexadecimal.
3. Buscamos los strings en la aplicación.
4. Disassembler en el malware para buscar llamadas y cambios de sistema.

### Análisis dinámico

¿Qué se debe observar?
- Información del sistema.
- Monitorización de cambios en ficheros, registros, usuarios, políticas, servicios, jobs y entorno del sistema.
- Escaneo en búsqueda de rootkits conocidos.
- ANSI o UNICODE strings en binarios.
- Sniffers o port-scanners
- Ficheros ocultos.
- TCP/UDP
- Generadores y valores de hashes.

Pasos:
1. Asegurarse de que todos los packs de servicios, parches y fixes están instalados en la VM antes de ejecutar el malware.
2. Asegurar la red de la VM.
3. Snapshot de la línea base.
4. Elegimos las herramientas.
5. Ejecutar el malware mientras observamos los procesos conexiones de red en ejecución.
6. Dejar al malware correr un rato.
7. Tomar una snapshot final.

### Post-análisis dinámico

- Comparación de snapshots.
- Cambios en los procesos en ejecución y nuevos procesos.
- Comprobación de las conexiones de red y listeners.
- Comprobación del tráfico de red capturado.

### Obtención y componentes del malware

El autor del malware puede usar aplicaciones, scripts y redes remotas para conseguir que el malware funcione.

Las aplicaciones pueden ser: Backdoors, Microsoft Remote Desktop, spam-bots, phishing en servidores própios, scripts de configuración de sistema.

Para obtener el malware podemos:
- Honeypots.
- Repositorios.
- Redes maliciosas.

# Examen 1: Cosas del Foro

### Conceptos teóricos

Bloatware: Las aplicaciones que aparecen en nuestro dispositivo por defecto. Pueden ser complicadas de eliminar.

Sexting: Acción o práctica de enviar contenido sexual o explícito a través de mensajes.

Grooming: Acción en la que un adulto inicia una conversación virtual con un menor con el objetivo de ganar su confianza.

Cyberstalking: Seguimiento o búsqueda de información sobre una persona a través de medios tecnológicos.

Pharming: Ciberestáfa que te redirige hacia una página falsa cuando quieres entrar en una web legítima para robar datos personales y financieros.

Flamming: Acto de atacar verbalmente o por escrito a través de redes sociales o videojuegos.

Creeping: Tipo de malware que se propaga lentamente y de manera encubierta a través de una red haciendo daño.

Cyberbulling: Efecto de recibir abusos a través de medios tecnológicos como redes sociales o aplicaciones de mensajería.

Ransomware attack: Ataque basado en encriptar o bloquear datos, arhcivos o discos completos para exigir a la víctima algo a cambio de su liberación (dinero).

Doxing: Es una abreviación de "dropping dox" siendo "dox" un término referido a documentos, por lo tanto con doxing nos referimos al acto de revelar información sobre alguien online, como psu nombre, correo, dirección, datos financieros, etc.

(Self-Mutating malware) Metamorphic Code: Código metamórfico es aquel que modifica su código y/o estructura en cada instancia de sí mismo. Cada vez que el malware infecta un equipo nuevo o distintos sectores de un sistema reescribe completamente partes de su código, modificando instrucciones por otras equivalentes. Se trata de un malware difícil de detectar debido a que cada "versión" del código parece ser única, aunque realiza las mismas acciones maliciosas, siendo muy efectivo ante métodos de detección basados en patrones.

(Self-Mutating malware) Polymorphic code: Es una técnica implementada por malware para cambiar su "apariencia" cada vez que infecta un nuevo sistema. Este cambio de apariencia se basa en cambiar sus características identificables como código, nombres de ficheros, llaves de encriptado y firma. La diferencia con código metamórfico es que este usa cifrado y el otro no.

### Preguntas más extensas

#### Evolución del registro de windows

Primera diferencia principal es la implementación de la virtualización del registro. Principalmente es una tecnología que en vez de realizar operaciones de escritura en el registro mediante permisos de administrados, estas se redirigen a ubicaciones por usuario.

Este enfoque permite que las aplicaciones funcionen sin necesidad de ser ejecutadas con privilegios, mejorando la compatibilidad y la seguridad. Además la introducción del control de cuentas de usuario refierza la seguridad al restringir los privilegios de las aplicaciones previniendo las modificaciones no autorizadas en el sistema.

#### Código ensamblador

??

# Cuckoo Sandbox

Las Sandboxes son entornos aislados para ejecución de malware, son herramientas para registrar las actividades del malware y generar un reporte.

Resumen: Usa una VM sen la que corre un agente que analiza la actividad del malware y recupera a una snapshot previa con el análisis ya hecho.

### Configuración

Lo primero que se debe hacer es configurar la aplicación (/conf):
- cuckoo.conf: Configuración de la VM, timeouts de análisis y selección entre VB y KVM.
- virtualbox.conf: Configuración de virtualbox con la plataforma del SO y la dirección IP.
- kvm.conf: Para KVM.
- reporting.conf: Formato del reporte.

### Inicialización

Antes de iniciar el análisis es necesario copiar e instalar el agente en la VM, librerías python para el agente y una snapshot con el agente ya corriendo.

### Ejecución

Para iniciar la aplicación hay que ejecutar el script cuckoo.py en el host. Tras esto es necesario enviar el archivo a analizar a través del submit.py (/utils).

### Terminación

Durante la ejecución las comunicaciones entre el host y la VM aparecen en una ventana de terminal.

Cuando la ejecución se termina, la máquina vuelve a la snapshot inicial.

El post análisis se realiza en storage/analysis:
- files: ficheros creados durante la ejecución.
- logs: aparecen metodos llamados del sistema y ddls.
- reports: formato configurado previamente.

### Limitaciones

Cuckoo es un software cada vez más popular, por lo que los malware están empezando a tomar medidas antianálisis para evitarlo.

Formas de detectarlo: Resolución de pantalla, núcleos e historial de búsqueda.

#### FlareVM

Es una herramienta para Windows que contiene una colección de scripts software para hacer y mantener entornos de ingeniería inversa.

Flare VM se basa en dos tecnologías:
- Chocolatey: Sistema de gestión de paquetes donde los paquetes son Zips de Powershell que instala y configura herramientas.
- Boxstarter: Aprovecha paquetes de Chocolatey para automatizar la instalación de software y crear entornos windows scripteados.

#### REMnux

REMnux es un toolkit de Linux para realizar ingeniería inversa y análisis de software malicioso.

Proporciona una colección de herramientas gratuitas, imágenes de Docker para análisis de malware en contenedores.

# Contramedidas del malware

El código del malware puede aplicar varias contramedidas contra la ingeniería inversa:
- Obfuscación de strings.
- Codificación de datos.
- Ocultación de información.
- Encriptación de las comunicaciones de red.

### Obfuscación del código

Obfuscar u "oscurecer" el código consiste en transformar el programa manteniendo el comportamiento intacto, volviendolo más dificil de comprender.

Tres razones típicas:
- Proteger la propiedad intelectual.
- Reducir la efectividad de los antivirus.
- Ralentizar el análisis de malware.

## Codificación de datos

#### Cifrado simple

Operaciones de bits en los registros:
- ADD y SUB.
- ROL y ROR.
- ROT y XOR.

#### Detección de algoritmos estándar de cifrado

Podemos destacar varias formas de descubrir el algoritmo:
- Buscar en los strings e imports APIs de cifrado.
- Detectar constantes magicos de criptografía.
- Analizar la entropía de las distintas partes. 

#### Codificación personalizada

Esquemas de codificación "home-made", mezclando múltiples métodos de cifrado o creando algoritmos personalizados.

### Codificación inversa

El procedimiento de encontrar el esquema de codificación adecuado y cómo descifrarlo:
- Trazando la ejecución del programa buscando funciones de E/D.
- Averiguando cómo, cuando y donde se usan estas funciones. 

### Usar malware en su contra

El analista puede lanzar el malware dentro de un debugger y colocar breakpoints antes de los puntos de cifrado/descifrado. Se pueden cambiar punteros de memoria, cambiando el propio puntero o la memoria en él.

# Anti análisis

### Antidesensamblador

La mayoría de los desensambladores son lineales (Solo una instrucción a la vez y sin desviarse) o Flow-oriented (Examina cada instrucción y construye una lista de localizaciones donde saltar o llamar).

El malware se aprovecha de las heurísticas utilizando las suposiciones realizadas por el desensamblador. El malware puede introducir código para confundir el análisis del stack frame.

### Antidebugging

#### Windows API

El malware puede utilizar las llamadas a la API de Windows para buscar IsDebuggerPresent (PEB), CheckRemoteDebuggerPresent (local machine process), NtQueryInformationProcess y OutputDebugString.

#### Comprobaciones manuales

Manualmente el malware puede comprobar las flags: BeingDebugged, ProcessHeap y NTGlobal; o residuos en el sistema: Llaves de registro, ficheros o directorios específicos, debuggers populares o FindWindow.

#### Comprobaciones de código o tiempo

El malware puede buscar en su propio código interrupciones o breakpoints activos. Comprobar checksum en secciones de su código (no inmune a hardware). Puede comprobar el tiempo ya que cuando se debuggea la ejecución es más lenta o comprobar ticks usando QueryPerformanceCounter, GetTickCount o rdtsc.

### Anti máquinas virtuales

Las máquinas virtuales también dejan marcas en el sistema, como pueden ser: Instrucciones con distinta semántica (emulación).

### Anti antivirus

Los antivirus observan previamente a la ejecución (firmas, escaneos o heurísticas) y durante la ejecución ( hooks en librerías, monitorizaciones en la red o en ficheros). El malware puede utilizar técnicas que comprueban procesos corriendo, hooks en librerías, obfuscan su código o packers para la firma.

# Detección y eliminación

### Base de datos de indicadores de compromiso

Para muchas compañías el análisis del malware es una forma de comprobar que no hay malware nuevo, aislar infecciones y borrar malware presente.

Para esto es necesario una BDIC, que debería ser compartida entre empresas (No lo hacen).

Los indicadores deberían ser capaces de identificar malware por su IP, nombre de dominio, claves de registro, ficheros, hashes, etc. O complejos como una regla de IDS.

Debe desarrollarse evitando dar falsos negativos y positivos.

### Defensa ante el malware

Para proteger una red se deben instalar varias capas de defensa: Antivirus, Firewall, Proxy e IDS/IPS.

## Antivirus

Son programas cuyo objetivo es detectar y borrar software vírico. Con la aparición de internet los antivirus han evolucionado, llegando a realizar tareas como bloqueo en tiempo real, limpieza de ficheros y prevención de reinfecciones. Hoy en día también se encargan de otros tipos de malware (spyware, adware, gusanos...).

### Técnicas de detección

#### Firmas digitales

Búsqueda de hashes, firmas de red o de host y comparandolas con las de una base de datos de virus. Los autores de malware han escapado de esto mediante malware poli/metamórficos.

#### Heurística

Comprobar ficheros en busca de patrones de código similares a un grupo de virus relacionados mediante mutación o evolución.

#### Detección de rootkits

Los rootkits cambian cómo funciona el sistema operativo, por lo que pueden ser muy dificiles de detectar. Para quitarlos a veces es necesario una reinstalación del SO.

#### Protección en tiempo real

Monitorización de sistemas en busca de actividad maliciosa al insertar un USB, abrir un email, buscar en la web, etc.

### Problemas

Los antivirus a veces producen falsos positivos, identificando un fichero no malicioso como malware; esto puede causar grandes problemas, como se vió en 2007 dejando PCs inutilizados.

Dejar corriendo varios antivirus puede crear conflictos entre ellos( actualizaciones, deshabilitaciones, etc.) y degradación en el rendimiento (Videojuegos o apps).

### ClamAV

Un antivirus gratuito de Sourcefire. Enfocado a Linux, pero también versionado a windows. Para usarlo es necesario actualizar la base de datos de firmas de virus y usar los comandos freshclam (update) y clamscan (análisis).

Es posible crear tus propias firmas a análizar mediante la siguiente sintaxis: Name:Type:Offset:HexaCode

Se configura en dos ficheros clamd.conf y freshclam.conf. Además se puede añadir proxy webs para los updates.

### Firmas

Una firma identifica inequivocamente un fichero, usa las propiedades de los hashes. Estas firmas (hashes) se pueden utilizar para comprobar si un fichero ha sido modificado. Los autores de malware pueden utilizar bytes random sin modificar el funcionamiento, para producir distintos hashes para el mismo código.

### YARA

Herramienta para detección e investigación de malware. Está basado en reglas para crear descripciones de familias de malware usando patrones textuales o binarios.

Una descripción es una regla YARA, set de strings y una expresión booleana.

Es combinable con otras herramientas.

## Firewall

Un firewall es una sistema de seguridad de red que monitoriza y controla tráfico de entrada y salida en una red mediante reglas de seguridad. Un firewall se coloca entre una red conocida y una red exterior.

### Tipos

#### Network

Filtra el tráfico entre dos o más redes, se coloca en la puerta de salida de LANs, WANs e intranets. Muchas veces el equipo que hace de firewall también funciona como servidor DHCP o VPN.

#### Host-Based

Se coloca en ordenador y funciona como filtro del tráfico I/O en esa máquina. Funciona como un servicio, parte del SO o Endpoint.

### Capas

Un firewall actúa en distintas capas dependiendo de las reglas:
- Red: Nivel TCP/IP mediante IPs, puertos TCP/UDP, dominios o MACs.
- Aplicación: HTTP, FTP, etc.

### Políticas y NAT

Dos tipos de políticas: Restrictiva (tira todo y solo permite) o Permisiva (todo permitido y prohibe).

Además los firewall muchas veces realizan traducción de direcciones. Utilizan un rango de direcciones privadas para traducir , funciona como defensa ante exploración de redes.

## Proxy Server

Un proxy es un programa o equipo que funciona como intermediario en las peticiones de los clientes a otro servidor. Esta posición le permite realizar numerosas funciones como control de acceso, registro de tráfico, restricciones, anonimato, etc.

El proxy más popular es el proxy web, que soporta navegación web ( seguridad, rendimiento, anonimato, etc.).

### Tipos

Tipos de servidores proxy según donde se implementa:
- Proxy Local: Se coloca en la misma máquina del cliente que realiza las peticiones. Se utiliza para que el usuario pueda controlar el tráfico.
- Proxy externo: Entidad externa.

Tipos de Proxy:
- Forward Proxy: Se coloca cercano al cliente y se configura manualmente para lograr reducción en los tiempos de acceso (memoria caché) y como captura y redirección de tráfico a los usuarios (NAT).
- Reverse Proxy: Es aquel que se coloca en el lado del servidor y tiene las siguientes funcionalidades, capa de seguridad, balanceo de carga y encriptación (hardware).ww

### Pros y Contras

Ventajas:
- Aumento de velocidad mediante caché de recursos que se piden con frecuencia.
- Filtrado de peticiones, modificación de contenidos (parent control p.e)
- Anonimato de IP. 

Desventajas:
- Anonimato en aplicaciones que requieren identidad.
- Riesgos de privacidad.
- Cuello de botella en los fallos, provocando degradación de servicio.

### Squid

Es un software gratuito bajo GNU, funciona como HTTP web proxy. Se puede usar para mejorar el rendimiento de servidores mediante caché de peticiones, compartición de recursos y filtrado de tráfico.

Puede configurarse para utilizar ACLs para bloquear URLs mediante el fichero squid-block.acl.

# Sistemas de detección de intrusiones (IDS)

Un IDS es un prgrama que detecta accesos no autorizados a un ordenador o a una red. Tiene una serie de sensores virtuales que descubren anomalías que indican la presencia de malware.

Su funcionamiento se basa en analizar detalladamente el funcionamiento de la red y compararlo con patrones conocidos de ataques. Funciona en cohesión con el firewall.

### Mecanismos

Un IDS puede utilizar las siguiente técnicas para detectar un ataque:
- Basado en patrones: Analiza paquetes en la red y los compara con patrones de ataques conocidos y preconfigurados. Puede tardar un poco entre el inicio y la detección del ataque.
- Basado en heurística: Determina la actividad normal de la red (ancho de banda usado, puertos, protocolos y dispositivos) y alerta al administrados cuando algo cambia.

### Tipos

Podemos diferenciar los siguientes tipos dependiendo de la localización:
- HostIDS: Intenta detectar modificaciones que afecten a un nodo en particular y reporta las conclusiones.
- NetworkIDS: Analiza un segmento de red, capturando todo el tráfico.

Y también dependiendo de su funcionamiento:
- Pasivo: El sensor detecta una posible intrusión, guarda la información y manda una señal de alerta.
- Reactivo: El IDS responde ante la actividad maliciosa mediante la reprogramación del firewall, para bloquear el acceso. Un sistema que actúa previnendo el ataque se llama IDPS.

### Limitaciones

- Como los ataques suelen ser menores que las falsas alarmas, algunos ataques se ignoran.
- Los basados en firmas presentan un tiempo entre ataque e identificación.
- Deben mantenerse actualizadas las BD.
- No procesa paquetes encriptados.
- No es capaz de ayudar si los mecanismos de autenticación/identificación son débiles.

### Técnicas de evasión

- Fragmentación: Envío de paquetes fragmentados, evitando la firma.
- Evasión de defectos: Uso de puertos reconfigurados, es decir distintos a lo usual.
- Ataques de bajo ancho de banda coordinados: Si actúan numerosos ataques el IDS no es capaz de correlacionar los paquetes capturados.
- Direcciones de spoofing/proxy: Un proxy mal configurado permite saltar ente máquinas y no detectarse.
- Evasión de patrones: Cambios en los datos escapan los patrones.

### Otros problemas

Una solución IDS puede ser hardware, software o combinarse. BD y firmas requieren mucha memoria.

Se diferencian de los firewall en cuanto a que estos últimos limitan el acceso entre redes, pero no alertan de ataques internos.

## Snort

Sistema IDPS de código abierto creado en 1998. Fué creado para realizar análisis en tiempo real y forense sobre redes, pero ha evolucionado con los años. Puede usarse para detectar ataques, intentos de fingerprint, ataques semánticos, overflows de buffer y bloqueos de mensajes.

### Modos de operación

- Modo sniffer: lectura de paquetes de la red y display por pantalla.
- Packet logger.
- Intrusion detection: Realiza detección y análisis forense sobre la red.

### Capacidades

- Modo sniffer.
- Logger de paquetes.
- NIDS Mode (escaneo de paquetes).

Se pueden configurar múltiples modos mediante reglas y plugins. Snort automáticamente intentará meterse en modo NIDS buscando el archivo snort.conf si no se le metió nada de command line.

### Arquitectura

Packet Streaming -> Sniffing -> Decoder de paquetes -> Preprocesamiento -> Motor de detección -> Estapa de salida -> Logs

### Reglas

Los elementos antes de los paréntesis son la cabecera de la regla:
- Acción a realizar.
- Protocolo.
- Ip externa.
- Puerto origen.
- Dirección.
- Dirección destino.
- Puerto destino.

Los elementos entre paréntesis son las opciones de la regla.
- Mensaje para los logs.
- Flags.
- Datos a buscar en el paquete.
- Referencia.
- Identificador 
- Tipo de regla.
- Número de revisión.

# Respuesta ante incidencias

La respuesta ante incidencias es un conjunto de pasos organizados ante una brecha de seguridad.

El objetivo es gestionar la situación limitando daños, recuperación y costes.

Los planes deben hacerse previamente y a cargo de diferentes miembros de la organización. El proceso se compone de seis pasos:

### Preparación

Primero se establecerán políticas para indentificar quien es el responsable de responder ante los incidentes, estas deben proteger al que gestiona y a la organización.

Siguiente se deberán crear relaciones entre todos los grupos participantes: Recursos humanos, consultoría legal, Tecnologías de la información, Seguridad, relaciones públicas, etc.

Se preparará un "jump kit": hardware, software, llamadas, etc. Se deberá incluir un plan de comunicaciones y una lista de objetivos. La lista se debe mantener actualizada según los pasos que vamos tomando.

Preparamos un modelo de amenaza para identificar los tipos de amenazas a los que la organización se puede enfrentar. Tras identificar estas amenazas se puede organizar el equipo de respuesta. La última etapa sería practicar en escenarios simulados.

### Identificación

El equipo debe identificar qué está causando el problema. Se realiza análisis de malware, identificando toda la información posible para los próximos pasos.

### Contención

Se deben desconectar los equipos afectados de la red, pero manteniendo los equipos conectados. Se protegerán el resto de equipos mediante las políticas pertinentes. No se deben apagar los equipos comprometidos, para mantener evidencias.

### Erradicación

Comienza el proceso de limpieza. En ocasiones es necesario una reconstrucción completa del sistema, en este caso será necesario asegurarse de que las memorias de backup no están comprometidas.
Tras la limpieza es necesario ejecutar un análisis de vulnerabilidades.

### Recuperación

El sistema será colocado de vuelta en producción y monitoreado para buscar signos de reinfección. Deberá asegurarse de que el sistema ha sido analizado previamente.

### Lecciones aprendidas

Por último será necesario preparara documentación, buscar formas de mejorar tecnica y administrativamente el proceso de gestión de incidentes y generar un plan de enseñanza.

# Examen 2: Preguntas del foro

Magic Constant: Una constante mágica criptográfica es un valor específico utilizado dentro de los algoritmos criptográficos para inicializar un estado, controlar operaciones, garantizar la seguridad o aumentar la aleatoriedad. Estas constantes suelen elegirse mediante métodos teóricos o empíricos para que parezcan aleatorias, lo que las hace resistentes a la manipulación de los atacantes. Su objetivo es mejorar la seguridad, garantizar las propiedades criptográficas y hacer que los algoritmos sean más resistentes a los ataques.Se trata de valores cuidadosamente seleccionados que suelen derivarse de números primos, patrones o constantes matemáticas bien conocidas (proporción áurea, PI o e...)

Magic Constant (ENG): A cryptographic magic constant is an specific value used within cryptographic algorithms for various purposes, such as initializing a state, controlling operations, ensure security or increasing randomness. These constant are usually chosen through theoretical or empirical methods to appear random making them resistant to attacker manipulation. Their objective is to improve security, ensure cryptographic properties and make the algorithms more resistant to attacks.

As previously stated, magic constants are not random; they are carefully selected values that are usually derived from primes, patterns or well known mathematical constants( golden ratio, PI or e ...).

PEB : El Bloque de Entorno de Proceso es una estructura en modo usuario que almacena información accesible para el proceso. Este reside en el espacio de direcciones de modo usuario de cada proceso, contiene estructuras de datos aplicables a todo el proceso como parámetros de inicio y la dirección base del programa y está diseñado para ser usado por bibliotecas del sistema operativo.

Entropía: Es la medida del desorden o de la incertidumbre en un conjunto de datos posibles. Mide la cantidad de información que cabe esperar de una fuente de datos, cuanto más imprevisible, mayor entropía.