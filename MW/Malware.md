# Tema 1: 

## ¿Qué es el malware?

Software malicioso, es decir, código para lograr acciones "malvadas".

### ¿Para qué analizarlo?

- Comprobación de daño.
- Identificación de vulnerabilidades.
- Encontrar a los malos

### ¿Porqué hace malware la gente?

1. Inicios: Rober Morris hizo un malware de propagación para ver el tamaño de internet.
2. En los 90: Por gloria personal, displays.
3. Actualidad: Por dinero, contraseñas, tarjetas, etc.
4. Futuro?: Ciberguerras, obtención de inteligencia, zerodays...

### Malware a lo largo del tiempo

1998. Gusano Morris usa finger daemon.
1990. Mark Washburn malware polimórfico.
2001. Gusano Code Red usa un exploit de MS web server.
2004. Troyano Vundo publicidad.
2005. Sony infecta CDs con rootkit para prevenir piratería.
2008. Koobface RAT se propaga por Facebook y Myspace.
2008. /10 Stuxnet utiliza cuatro Zero-days en windows (Iran).
2013. Mandiant publica APT1, campaña china de ciber espionaje.
2015. Duqu2 evolución de Stuxnet, atacó Kapersky.

### Preguntas prácticas

1. ¿Propósito del malware?
2. ¿Cuando y cómo he sido infectado?
3. ¿De quién he sido objetivo?
4. ¿Cómo puedo evitarlo?
5. ¿Qué me han robado?
6. ¿Se esparce por si mismo?
7. ¿Cómo puedo encontrarlo en otra parte?
8. ¿ Cómo puedo evitar que ocurra en un futuro?

### Preguntas técnicas

1. ¿Indicios de red?
2. ¿Indicios en envíos de mensajes?
3. ¿Persistencia?
4. ¿Fecha de compilación?
5. ¿Fecha de instalación?
6. ¿Lenguaje de programación?
7. ¿Empaquetado?
8. ¿Tiene funcionalidades rootkit?

### Términos típicos

- Virus: Malware que intenta reproducirse en programas similares al que se encuentra hasta que consigue permisos para poder ejecutar su software malicioso.
- Gusano: Malware autocontenido que busca replicarse y esparcirse a lo largo de las redes disponibles para el equipo en el que se encuentra.
- Trojan: Programa que de primeras parece útil o seguro, pero después producen acciones maliciosas.
- Backdoor: Puertas ocultas para que un atacante o empresa pueda acceder al sistema sin tener en cuenta la seguridad.
- Rootkit: Herramientas que modifican el sistema operativo para que el ataque permanezca oculto en el sistema.
- Sniffer: Software o hardware que recoje paquetes en un canal de comunicación para su monitorización o análisis.
- Spyware: Software instalado en un equipo sin que el usuario sea consciente, el cual obtiene información privada.
- Adware: Software instalado que informa sobre hábitos de búsqueda y gustos del usuario para propósitos publicitarios.
- Exploit: Software o secuencia de comandos que aprovecha un bug o una vulnerabilidad para producir comportamiento inesperado en el sistema.
- Disassembler:  Programa que recibe un archivo binario y genera ficheros de texto con el lenguaje ensamblador para el programa.
- Decompiler: Programa que recibe un archivo binario ejecutable e intenta producir lenguaje de alto nivel legible.
- Debugger: Programa que permite a los desarrolladores observar el proceso del código durante su ejecución.
- Profilers: 
- Sinkhole: Host en la red interna que recibe trafico redireccionado de dominios maliciosos.
- IDS (Sistema de detección de intrusiones): Software/Hardware para detectar acceso no autorizado a un host o a una red.
- IPS (Intrusion Prevention System): Igual que IDS, pero intentan parar las intrusiones.
- Operations Security (OPSEC): El proceso de prevenir adversarios de obtener información sensible.
- Reverse Engineering: Es el proceso de a partir de un producto inicial, intentar determinar cuales son sus componentes, cómo interactúan entre sí y su proceso de desarrollo.

### Extras

Ransomware, Creeping, Vamping, Sexting, Phising, Pharming, Bloatware, Doxing, Grooming, Cyberbulling, Cyberstalking, Flaming.

# Tema 1.2: Goals and Types

### Goals of Malware Analysis

El objetivo del análisis de malware es comprender cómo una pieza de malware específica funciona y como protegerse ante ella.

Three questions:
- Cómo terminó infectada la máquina?
- Que hace exactamente?
- Cómo podemos prevenirlo?

### Types of Malware Analysis

Existen dos tipos de análisis estático o de código y dinámico o de comportamiento.

Es importante realizar ambos análisis para averiguar cómo funciona perfectamente.

### Análisis estático

El análisis estático es más seguro, pero es más lento y tedioso, hay un montón de herramientas incluidas.

Durante el análisis de código, software antivirus analizará malware, scripts y búsqueda de cadenas específicas.

Al hacer reverse coding es importante revisar las leyes nacionales.

Tras terminar el análisis es importante entender como funciona el código base.

### Analisis dinámico

Es una forma más veloz de analizar, pero es importante no tener el laboratorio de pruebas conectado a una red externa.

El análisis dinámico se basa en observar cómo el malware se comporta y qué cambios provoca en el sistema base. Hay que comprobar cambios en el sistema y comportamientos inusuales.

Los cambios en el sistema que provocan un aviso deberían ser:
- Ficheros añadidos y/o modificados.
- Nuevos servicios de red instalados.
- Nuevos procesos.
- Modificaciones en los registros.
- Cambios en la configuración de servicios del sistema (DNS).

Además de lo último es necesario examinar el tráfico.

Extras-Armored malware: Encryption, Compression, Obfuscation, Anti-Patching(CRC check), Anti-tracing, Anti-unpacking, Anti-vmware, Self-mutating(poli/meta-morphic), Restrictive dates, Password protected.

# x86 Architecture

### Niveles de abstracción

Application > Algorithm > Programming Language > Assembly Language > Machine Code > Instruction Set Architecture > Micro Architecture > Gates/Registers > Devices(Transistors) > Physics

### Ingeniería inversa

En algunos lenguajes existen decompiladores que proveen descripción de código de alto nivel.

Normalmente el lenguaje ensamblador es la capa más alta en la que se puede recuperar los datos de forma consistente.

## x86 Architecture

Es el objetivo más explotado debido a que es el tipo de arquitectura más utilizado: 32-bits y 64-bits.

### Instrucciónes y Operadores

- Instrucción: Cada instrucción corresponde a un código de operación que indica al procesador que operación realizar.
- Operadores: Se usan para identificar los datos utilizados por una instrucción( Valores fijos, Registros u operaciones de memoria).

### Registros

- Registros generales: usados por la CPU.
- Registros de segmento: Usados para trackear secciones de memoria.
- Flags de estado: Para la toma de decisiones.
- Puntero de instrucciones (EIP): Para trackear la siguiente instrucción.

### Flags

El registro de EFLAGS tiene 32 bits. Cada bit es una flag(1,0), controlan operaciones de la CPU o resultados de operaciones.

- ZF(Zero flag): Cuando el resultado es 0.
- CF(Carry Flag): Cuando el resultado es demasiado grande o pequeño para el destino.
- SF(Sign Flag): Cuando el resultado es negativo.
- TF(Trap Flag): Para debugging.

#### Instrucciones de datos

- mov destination, source: moves data from source to destination.
- lea destination, source: loads an effective addres to a destination.

#### Instrucciones aritméticas

- add/sub
- mul/div
- Logical (or/and/xor)
- shr/shl destination, count: Shift registers right/left
- ror/rol rotation instruccions: Rotate bits to the other end.

#### Llamadas a funciones

- Prólogo de funciones: Lineas al inicio que preparan el stack y registros.
- Epílogo de funciones: Líneas al final de una funcion, recuperan el estado del stack y los registros previos a la función.

### El Stack de memoria

El stack crece desde una dirección alta de memoria hacia zero.

Current stack < Caller's stack < 

Instrucciones: push, pop, call, ret, enter y leave.

Convenciones: cdecl (limpia el stack), stdcall (limpia el stack antes de hacer return), fastcall (Los primeros argumentos pasan a los registros).

Dentro de un function stack frame dado las variables estarán en un offset negativo desde EBP y los argumentos en un offset positivo.

#### Condicionales

- test value,value: Idéntico a la instrucción and, pero los operadores no se modifican, solo settea la ZF.

- cpm destination, source: Idéntico a sub, pero no afecta a los operadores, se actualizan ZF y SF.

#### Ramas (Branching)

- jmp location: Una rama es una secuencia de código que se ejecuta condicionalmente saltando un grupo de instrucciones.

#### Repeticiones

- rep instructions: Set de instrucciones para manipular buffers de datos como arrays de bytes usando movsx, cmpsx, stosx, scasx.

scasx: Def FORO, comparar un valor almacenado en un registro con un valor en la memoria (específicamente en la dirección apuntada por el registro ESI o EDI, dependiendo del modo). Es parte del grupo de instrucciones conocidas como String Operations (operaciones con cadenas) y se utiliza para recorrer y comparar secuencias de datos en la memoria.

# The Microsoft Arquitecture

### Windows API

La API de windows es la forma estándar de interactuar con el SO y se usa en los DLLs.

Destacado: kernel32, wininet.dll, advapi32.dll.

### Proccesses, Threads and Context

Proceso: Contenedor de recursos que tiene su propio espacio de direcciones virtuales, hilos e información.

Hilos: Gestionados y ejecutados por el SO, los hilos pertenecen a un único proceso y comparten su espacio de direcciones.

Contexto de hilos: El contexto de hilos trackea el estado de un hilo (valores en registros).

### Dynamic Link Library (DLL)

Son librerías que se enlazan solo cuando se necesitan, por ejemplo al abrir una carpeta, así pesan menos y solo se enlazan al necesitar funcionalidades.

Todos los procesos comparten las DLLs cargadas, esto guarda espacio y cada cambio solo afecta el espacio de direcciones de ese proceso.

Los DLLs exportan un método interfazo que será usado por los procesos.

#### Registros

Un arbol jerárquico en el que se guarda información de forma: clave-valor. regedit para navegarlo.

#### Servicios

Un servicio es similar a un proceso pero instalado en el disco/registro. No los genera el usuario sino por el sistema y cumplen funcionalidades esenciales en segundo plano.

#### Handlers

Un puntero abstracto a un proceso,fichero,clave del registro,servicio,etc.

### .com Files vs COM Platform

Un archivo .com es un ejecutable de 8bits de la época MS-DOS, con un tamaño máximo de 64KB (DOS-segment) que guarda código y datos.
Se usan por escritores de malware para aprovecharse de ususarios sin conocimientos que lo vinculan a las url .com.

Un "Component Object Model" es un estándar de interfaz binario para componentes de software introducido por Microsoft en 1993. En esencia es un lenguaje neutro para implementar objetos que pudieran ser ejecutados en entornos diferentes a aquel en el que se crearon.
Problema: Los componentes COM se ejecutan como código nativo en la máquina del usuario, por lo que apenas tienen restricciones.

# Malware analysis and tools

#### Create a Sandbox

### Ventajas y desventajas de la virtualización

#### Virtualización del SO

#### Análisis de la virtualización

### Análisis estático

### Análisis dinámico

### Post-análisis dinámico

### Obtención y componentes del malware

# Cuckoo Sandbox

Las Sandboxes son entornos aislados para ejecución de malware, son herramientas para registrar las actividades del malware y generar un reporte.

Resumen: Usa una VM sen la que corre un agente que analiza la actividad del malware y recupera a una snapshot previa con el análisis ya hecho.

### Configuración

Lo primero que se debe hacer es configurar la aplicación (/conf):
- cuckoo.conf: Configuración de la VM, timeouts de análisis y selección entre VB y KVM.
- virtualbox.conf: Configuración de virtualbox con la plataforma del SO y la dirección IP.
- kvm.conf: Para KVM.
- reporting.conf: Formato del reporte.

### Inicialización

Antes de iniciar el análisis es necesario copiar e instalar el agente en la VM, librerías python para el agente y una snapshot con el agente ya corriendo.

### Ejecución

Para iniciar la aplicación hay que ejecutar el script cuckoo.py en el host. Tras esto es necesario enviar el archivo a analizar a través del submit.py (/utils).

### Terminación

Durante la ejecución las comunicaciones dentre el host y la VM aparece en una ventana de terminal.

Cuando la ejecución se termina, la máquina vuelve a la snapshot inicial.

El post análisis se realiza en storage/analysis:
- files: ficheros creados durante la ejecución.
- logs: aparecen metodos llamados del sistema y ddls.
- reports: formato configurado previamente.

### Limitaciones

Cuckoo es un software cada vez más popular, por lo que los malware están empezando a tomar medidas antianálisis para evitarlo.

Formas de detectarlo: Resolución de pantalla, núcleos e historial de búsqueda.

#### FlareVM

Es una herramienta para Windows que contiene una colección de scripts software para hacer y mantener entornos de ingeniería inversa.

Flare VM se basa en dos tecnologías:
- Chocolatey: Sistema de gestión de paquetes donde los paquetes son Zips de Powershell que instala y configura herramientas.
- Boxstarter: Aprovecha paquetes de Chocolatey para automatizar la instalación de software y crear entornos windows scripteados.

#### REMnux

REMnux es un toolkit de Linux para realizar ingeniería inversa y análisis de software malicioso.

Proporciona una colección de herramientas gratuitas, imágenes de Docker para análisis de malware en contenedores.

# Contramedidas del malware

El código del malware puede aplicar varias contramedidas contra la ingeniería inversa:
- Obfuscación de strings.
- Codificación de datos.
- Ocultación de información.
- Encriptación de las comunicaciones de red.

### Obfuscación del código

Obfuscar u "oscurecer" el código consiste en transformar el programa manteniendo el comportamiento intacto, volviendolo más dificil de comprender.

Tres razones típicas:
- Proteger la propiedad intelectual.
- Reducir la efectividad de los antivirus.
- Ralentizar el análisis de malware.

## Codificación de datos

#### Cifrado simple

Operaciones de bits en los registros:
- ADD y SUB.
- ROL y ROR.
- ROT y XOR.

#### Detección de algoritmos estándar de cifrado

Podemos destacar varias formas de descubrir el algoritmo:
- Buscar en los strings e imports APIs de cifrado.
- Detectar constantes magicos de criptografía.
- Analizar la entropía de las distintas partes. 

#### Codificación personalizada

Esquemas de codificación "home-made", mezclando múltiples métodos de cifrado o creando algoritmos personalizados.

### Codificación inversa

El procedimiento de encontrar el esquema de codificación adecuado y como descifrarlo:
- Trazando la ejecución del programa buscando funciones de E/D.
- Averiguando cómo, cuando y donde se usan estas funciones. 

### Usar malware en su contra

El analista puede lanzar el malware dentro de un debugger y colocar breakpoints antes de los puntos de cifrado/descifrado. Se puedes cambiar punteros de memoria, añadir 